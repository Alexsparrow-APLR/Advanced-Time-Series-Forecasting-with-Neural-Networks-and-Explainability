# ==========================================================
# 1. Import Libraries
# ==========================================================
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from sklearn.preprocessing import MinMaxScaler
from sklearn.metrics import mean_squared_error, mean_absolute_error
import tensorflow as tf
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import LSTM, Dense, Dropout
from tensorflow.keras.callbacks import EarlyStopping
import shap
from statsmodels.tsa.arima.model import ARIMA
import warnings
warnings.filterwarnings("ignore")

np.random.seed(42)
tf.random.set_seed(42)

# ==========================================================
# 2. Generate Synthetic Time Series Dataset
# ==========================================================
def generate_time_series(n=1000):
    t = np.arange(n)
    trend = 0.05 * t
    seasonality = 10 * np.sin(2 * np.pi * t / 50)
    noise = np.random.normal(0, 2, n)
    series = trend + seasonality + noise
    return pd.DataFrame({"value": series})

df = generate_time_series(1200)

plt.figure(figsize=(10,4))
plt.plot(df['value'])
plt.title("Generated Time Series")
plt.show()

# ==========================================================
# 3. Preprocessing (Scaling + Windowing)
# ==========================================================
scaler = MinMaxScaler()
scaled_data = scaler.fit_transform(df[['value']])

def create_sequences(data, lookback=30, horizon=5):
    X, y = [], []
    for i in range(len(data) - lookback - horizon):
        X.append(data[i:i+lookback])
        y.append(data[i+lookback:i+lookback+horizon])
    return np.array(X), np.array(y)

LOOKBACK = 30
HORIZON = 5

X, y = create_sequences(scaled_data, LOOKBACK, HORIZON)

# Train-Test Split
split = int(len(X) * 0.8)
X_train, X_test = X[:split], X[split:]
y_train, y_test = y[:split], y[split:]

# ==========================================================
# 4. Build LSTM Model
# ==========================================================
def build_model(units=50, dropout=0.2):
    model = Sequential([
        LSTM(units, return_sequences=False, input_shape=(LOOKBACK, 1)),
        Dropout(dropout),
        Dense(HORIZON)
    ])
    model.compile(optimizer='adam', loss='mse')
    return model

# Hyperparameter tuning (manual grid)
best_model = None
best_loss = float("inf")

for units in [32, 50]:
    for dropout in [0.2, 0.3]:
        print(f"Training model: units={units}, dropout={dropout}")
        model = build_model(units, dropout)
        history = model.fit(
            X_train, y_train,
            epochs=20,
            batch_size=32,
            validation_split=0.2,
            verbose=0,
            callbacks=[EarlyStopping(patience=5)]
        )
        val_loss = min(history.history['val_loss'])
        if val_loss < best_loss:
            best_loss = val_loss
            best_model = model

print("Best validation loss:", best_loss)

# ==========================================================
# 5. Evaluation
# ==========================================================
y_pred = best_model.predict(X_test)

# Inverse scaling
y_test_inv = scaler.inverse_transform(
    y_test.reshape(-1,1)).reshape(y_test.shape)
y_pred_inv = scaler.inverse_transform(
    y_pred.reshape(-1,1)).reshape(y_pred.shape)

def evaluate(y_true, y_pred):
    rmse = np.sqrt(mean_squared_error(y_true.flatten(), y_pred.flatten()))
    mae = mean_absolute_error(y_true.flatten(), y_pred.flatten())
    mape = np.mean(np.abs((y_true - y_pred) / y_true)) * 100
    return rmse, mae, mape

rmse, mae, mape = evaluate(y_test_inv, y_pred_inv)

print("LSTM Performance:")
print("RMSE:", rmse)
print("MAE:", mae)
print("MAPE:", mape)

# ==========================================================
# 6. Baseline Model (ARIMA)
# ==========================================================
train_series = df['value'][:split+LOOKBACK]
test_series = df['value'][split+LOOKBACK:]

arima_model = ARIMA(train_series, order=(5,1,0))
arima_result = arima_model.fit()

arima_forecast = arima_result.fore